#!/usr/bin/env node
/**
 * merge-to-single.js
 *
 * Usage:
 *   node merge-to-single.js /path/to/repo /path/to/output.html
 *
 * What it does:
 * - Recursively finds all .css and .js files (skips node_modules, .git).
 * - If an index.html exists in repo root, it inlines CSS into <head> (before </head>)
 *   and inlines JS before </body>.
 * - If index.html not found, it uses a built-in simple template and injects the bundles.
 *
 * Notes:
 * - Images and other binary assets are NOT inlined. If your HTML references images,
 *   leave them as-is or convert to data URIs manually.
 * - Order: files are concatenated in alphabetical path order. If ordering matters,
 *   adjust file names or modify script to use an explicit order list.
 */

const fs = require('fs');
const path = require('path');

if (process.argv.length < 4) {
  console.error('Usage: node merge-to-single.js /path/to/repo /path/to/output.html');
  process.exit(1);
}

const repoDir = path.resolve(process.argv[2]);
const outFile = path.resolve(process.argv[3]);

function walk(dir, extensions, acc = []) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const e of entries) {
    if (e.name === 'node_modules' || e.name === '.git' || e.name === 'dist') continue;
    const full = path.join(dir, e.name);
    if (e.isDirectory()) {
      walk(full, extensions, acc);
    } else {
      const ext = path.extname(e.name).toLowerCase();
      if (extensions.includes(ext)) acc.push(full);
    }
  }
  return acc;
}

function readFiles(pathsArr) {
  const parts = [];
  for (const p of pathsArr.sort()) {
    try {
      const txt = fs.readFileSync(p, 'utf8');
      // Add a comment showing source
      parts.push(`/* ===== file: ${path.relative(repoDir, p)} ===== */\n${txt}\n`);
    } catch (err) {
      console.warn('Could not read', p, err.message);
    }
  }
  return parts.join('\n');
}

// find index.html at repo root
const indexHtmlPath = path.join(repoDir, 'index.html');
let baseHtml = null;

if (fs.existsSync(indexHtmlPath)) {
  baseHtml = fs.readFileSync(indexHtmlPath, 'utf8');
  console.log('Found index.html in repo root, will inline into it.');
} else {
  console.log('No index.html in repo root, using built-in template.');
  baseHtml = `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Merged â€” CallHub</title>
  <!-- INLINE_CSS_PLACEHOLDER -->
</head>
<body>
  <!-- If your repo had HTML fragments, paste them here or ensure index.html existed -->
  <div id="app">
    <h1>CallHub (merged)</h1>
    <p>Replace this body with your app HTML or provide index.html in repo root.</p>
  </div>

  <!-- INLINE_JS_PLACEHOLDER -->
</body>
</html>`;
}

// collect css and js
const cssFiles = walk(repoDir, ['.css']);
const jsFiles = walk(repoDir, ['.js']);

const cssBundle = readFiles(cssFiles);
const jsBundle = readFiles(jsFiles);

// prepare injection
const cssTag = `<style>\n/* Inlined CSS bundle (${cssFiles.length} files) */\n${cssBundle}\n</style>`;
const jsTag = `<script>\n// Inlined JS bundle (${jsFiles.length} files)\n${jsBundle}\n</script>`;

let outHtml = baseHtml;

// If placeholders exist, use them; otherwise try to intelligently insert
if (outHtml.includes('<!-- INLINE_CSS_PLACEHOLDER -->')) {
  outHtml = outHtml.replace('<!-- INLINE_CSS_PLACEHOLDER -->', cssTag);
} else {
  // insert before </head>
  outHtml = outHtml.replace(/<\/head>/i, `${cssTag}\n</head>`);
}

if (outHtml.includes('<!-- INLINE_JS_PLACEHOLDER -->')) {
  outHtml = outHtml.replace('<!-- INLINE_JS_PLACEHOLDER -->', jsTag);
} else {
  // insert before </body>
  outHtml = outHtml.replace(/<\/body>/i, `${jsTag}\n</body>`);
}

// write output
fs.writeFileSync(outFile, outHtml, 'utf8');
console.log('Wrote merged output to', outFile);
console.log('CSS files inlined:', cssFiles.length, 'JS files inlined:', jsFiles.length);
